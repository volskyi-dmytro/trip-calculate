name: Deploy to Production (VPS)

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Setup Node.js for React frontend build
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      # Build React frontend with environment variables
      - name: Build React Frontend
        env:
          VITE_N8N_WEBHOOK_URL: ${{ secrets.PROD_N8N_WEBHOOK_URL }}
          VITE_GEMINI_API_KEY: ${{ secrets.PROD_GEMINI_API_KEY }}
          VITE_MAPBOX_TOKEN: ${{ secrets.MAPBOX_ACCESS_TOKEN }}
          VITE_API_URL: ""
        run: |
          cd frontend
          npm ci
          npm run build

      # Copy React build to Spring Boot static resources
      - name: Copy Frontend to Spring Boot
        run: |
          echo "üì¶ Cleaning static directory..."
          rm -rf src/main/resources/static/*
          mkdir -p src/main/resources/static
          cp -r frontend/dist/* src/main/resources/static/

          echo "‚úÖ Verifying build artifacts..."
          ls -la src/main/resources/static/index.html || { echo "‚ùå index.html missing!"; exit 1; }
          
          BUNDLE=$(grep -o "index-[^.]*\.js" src/main/resources/static/index.html | head -1)
          echo "üì¶ Bundle: $BUNDLE"
          ls -la "src/main/resources/static/assets/$BUNDLE" || { echo "‚ùå Bundle missing!"; exit 1; }

      # Setup Java and build Spring Boot
      - uses: actions/setup-java@v4
        with: 
          distribution: temurin
          java-version: '17'
          cache: maven

      # Build Spring Boot JAR
      - name: Build Spring Boot JAR
        run: |
          echo "üî® Building Production JAR..."
          mvn clean package -DskipTests

          echo "‚úÖ Verifying static assets in JAR..."
          jar tf target/*.jar | grep "BOOT-INF/classes/static/index.html" || { echo "‚ùå index.html not in JAR!"; exit 1; }

          echo "‚úÖ Verifying application.properties in JAR..."
          jar tf target/*.jar | grep "BOOT-INF/classes/application.properties" || { echo "‚ùå application.properties not in JAR!"; exit 1; }

          echo "‚úÖ Verifying application-prod.properties in JAR..."
          jar tf target/*.jar | grep "BOOT-INF/classes/application-prod.properties" || { echo "‚ùå application-prod.properties not in JAR!"; exit 1; }

          echo "‚úÖ All required files verified in JAR"

      # Build and push Docker image with production tag
      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          echo "üì¶ Listing JARs in target directory..."
          ls -lh target/*.jar

          echo "üî® Building Docker image..."
          docker build -t ${{ secrets.DOCKER_USERNAME }}/trip-calculate:latest \
                       -t ${{ secrets.DOCKER_USERNAME }}/trip-calculate:prod-${{ github.sha }} .

          echo "üîç Verifying properties files in built Docker image BEFORE pushing..."
          CONTAINER_ID=$(docker create ${{ secrets.DOCKER_USERNAME }}/trip-calculate:latest)
          docker cp $CONTAINER_ID:/app/trip-calculate.jar /tmp/verify-docker.jar
          docker rm $CONTAINER_ID

          jar tf /tmp/verify-docker.jar | grep "BOOT-INF/classes/application.properties" || { echo "‚ùå application.properties missing from Docker image!"; exit 1; }
          jar tf /tmp/verify-docker.jar | grep "BOOT-INF/classes/application-prod.properties" || { echo "‚ùå application-prod.properties missing from Docker image!"; exit 1; }
          echo "‚úÖ Properties files verified in Docker image"
          rm /tmp/verify-docker.jar

          docker push ${{ secrets.DOCKER_USERNAME }}/trip-calculate:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/trip-calculate:prod-${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/vps_deploy_key
          chmod 600 ~/.ssh/vps_deploy_key
          
          if [ -n "${{ secrets.VPS_KNOWN_HOSTS }}" ]; then
            echo "${{ secrets.VPS_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          fi

      - name: Deploy to VPS
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
          DATABASE_USERNAME: ${{ secrets.PROD_DATABASE_USERNAME }}
          DATABASE_PASSWORD: ${{ secrets.PROD_DATABASE_PASSWORD }}
          GOOGLE_CLIENT_ID: ${{ secrets.PROD_GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.PROD_GOOGLE_CLIENT_SECRET }}
          OAUTH_REDIRECT_URI: ${{ secrets.PROD_OAUTH_REDIRECT_URI }}
          GMAIL_USERNAME: ${{ secrets.GMAIL_USERNAME }}
          GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          MAPBOX_ACCESS_TOKEN: ${{ secrets.MAPBOX_ACCESS_TOKEN }}
          REDIS_PASSWORD: ${{ secrets.PROD_REDIS_PASSWORD }}
          N8N_WEBHOOK_URL: ${{ secrets.PROD_N8N_WEBHOOK_URL }}
        run: |
          ssh -i ~/.ssh/vps_deploy_key $VPS_USER@$VPS_HOST "DOCKER_USERNAME='${DOCKER_USERNAME}' DATABASE_URL='${DATABASE_URL}' DATABASE_USERNAME='${DATABASE_USERNAME}' DATABASE_PASSWORD='${DATABASE_PASSWORD}' GOOGLE_CLIENT_ID='${GOOGLE_CLIENT_ID}' GOOGLE_CLIENT_SECRET='${GOOGLE_CLIENT_SECRET}' OAUTH_REDIRECT_URI='${OAUTH_REDIRECT_URI}' GMAIL_USERNAME='${GMAIL_USERNAME}' GMAIL_APP_PASSWORD='${GMAIL_APP_PASSWORD}' ADMIN_EMAIL='${ADMIN_EMAIL}' MAPBOX_ACCESS_TOKEN='${MAPBOX_ACCESS_TOKEN}' REDIS_PASSWORD='${REDIS_PASSWORD}' N8N_WEBHOOK_URL='${N8N_WEBHOOK_URL}' bash -s" <<'REMOTE'
            echo "üöÄ Deploying to Production VPS..."

            # Create private Docker network if it doesn't exist
            docker network inspect trip-calculate-network >/dev/null 2>&1 || docker network create trip-calculate-network

            # Connect database to network if not already connected
            docker network connect trip-calculate-network trip-calculate-db 2>/dev/null || echo "‚úÖ Database already on network"

            # ==================== SECURITY CHECKS ====================
            echo "üîí Running security verification..."
            
            # Check database port exposure
            if docker port trip-calculate-db 2>/dev/null | grep -q "5432"; then
              echo "‚ö†Ô∏è WARNING: Database port 5432 is EXPOSED to internet!"
              echo "‚ùå Failing deployment for security reasons"
              exit 1
            else
              echo "‚úÖ Database security verified - port 5432 NOT exposed"
            fi

            # ==================== REDIS SETUP ====================
            echo ""
            echo "üî¥ Setting up Redis cache..."
            
            # Check if Redis container exists
            if docker ps -a --format '{{.Names}}' | grep -q "^trip-calculate-redis$"; then
              echo "‚úÖ Redis container exists"
              
              # Check if running
              if ! docker ps --format '{{.Names}}' | grep -q "^trip-calculate-redis$"; then
                echo "‚ö†Ô∏è Redis container stopped, starting..."
                docker start trip-calculate-redis
              else
                echo "‚úÖ Redis already running"
              fi
            else
              echo "üì¶ Creating new Redis container..."
              docker run -d \
                --name trip-calculate-redis \
                --network trip-calculate-network \
                --restart unless-stopped \
                -v trip-calculate-redis-data:/data \
                redis:7-alpine redis-server --requirepass "${REDIS_PASSWORD}"
              
              echo "‚úÖ Redis container created"
            fi

            # Wait for Redis to be ready
            echo "‚è≥ Waiting for Redis to be ready..."
            sleep 3

            # Verify Redis health
            echo "üîç Verifying Redis connectivity..."
            if docker exec trip-calculate-redis redis-cli -a "${REDIS_PASSWORD}" ping 2>/dev/null | grep -q "PONG"; then
              echo "‚úÖ Redis health check passed"
            else
              echo "‚ùå Redis health check failed"
              echo "üìã Redis logs:"
              docker logs trip-calculate-redis --tail 20
              exit 1
            fi

            # Check Redis port exposure (security)
            if docker port trip-calculate-redis 2>/dev/null | grep -q "6379"; then
              echo "‚ö†Ô∏è WARNING: Redis port 6379 is EXPOSED to internet!"
              echo "üîí Security Risk: Redis should NOT expose port 6379"
              exit 1
            else
              echo "‚úÖ Redis security verified - port 6379 NOT exposed"
            fi

            # ==================== APPLICATION DEPLOYMENT ====================
            echo ""
            echo "üì¶ Deploying application..."
            
            # Pull latest image
            docker pull "${DOCKER_USERNAME}/trip-calculate:latest"

            # Stop and remove old container
            docker stop trip-calculate-prod || true
            docker rm trip-calculate-prod || true

            # Run new container with Redis connection
            docker run -d -p 8080:8080 \
              --name trip-calculate-prod \
              --restart unless-stopped \
              --network trip-calculate-network \
              -e SPRING_PROFILES_ACTIVE=prod \
              -e DATABASE_URL="${DATABASE_URL}" \
              -e DATABASE_USERNAME="${DATABASE_USERNAME}" \
              -e DATABASE_PASSWORD="${DATABASE_PASSWORD}" \
              -e GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID}" \
              -e GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET}" \
              -e OAUTH_REDIRECT_URI="${OAUTH_REDIRECT_URI}" \
              -e GMAIL_USERNAME="${GMAIL_USERNAME}" \
              -e GMAIL_APP_PASSWORD="${GMAIL_APP_PASSWORD}" \
              -e ADMIN_EMAIL="${ADMIN_EMAIL}" \
              -e MAPBOX_ACCESS_TOKEN="${MAPBOX_ACCESS_TOKEN}" \
              -e REDIS_HOST=trip-calculate-redis \
              -e REDIS_PORT=6379 \
              -e REDIS_PASSWORD="${REDIS_PASSWORD}" \
              -e AI_CACHE_TTL_HOURS=24 \
              -e N8N_WEBHOOK_URL="${N8N_WEBHOOK_URL}" \
              "${DOCKER_USERNAME}/trip-calculate:latest"

            echo "‚úÖ Application container started"
            docker ps -a | grep trip-calculate

            # ==================== CONNECTIVITY VERIFICATION ====================
            echo ""
            echo "üîç Verifying inter-container connectivity..."
            sleep 5
            
            # Check database connectivity
            if docker exec trip-calculate-prod ping -c 2 trip-calculate-db >/dev/null 2>&1; then
              echo "‚úÖ Database connectivity verified"
            else
              echo "‚ùå Cannot reach database from application"
              exit 1
            fi

            # Check Redis connectivity
            if docker exec trip-calculate-prod ping -c 2 trip-calculate-redis >/dev/null 2>&1; then
              echo "‚úÖ Redis connectivity verified"
            else
              echo "‚ùå Cannot reach Redis from application"
              exit 1
            fi

            # ==================== HEALTH CHECK ====================
            echo ""
            echo "‚è≥ Waiting for application to start..."
            echo "üìä Monitoring startup progress..."

            RETRY_COUNT=0
            MAX_RETRIES=15  # Increased for Redis initialization
            RETRY_INTERVAL=5

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              sleep $RETRY_INTERVAL
              RETRY_COUNT=$((RETRY_COUNT + 1))

              echo "‚è≥ Attempt $RETRY_COUNT/$MAX_RETRIES - checking health endpoint..."

              if curl -f http://localhost:8080/actuator/health >/dev/null 2>&1; then
                echo "‚úÖ Application health check passed on attempt $RETRY_COUNT"
                curl -s http://localhost:8080/actuator/health | grep -o '"status":"[^"]*"'
                break
              fi

              if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                echo "‚ùå Health check failed after $MAX_RETRIES attempts!"
                echo ""
                echo "üìã Application logs:"
                docker logs trip-calculate-prod --tail 50
                echo ""
                echo "üî¥ Redis logs:"
                docker logs trip-calculate-redis --tail 20
                echo ""
                exit 1
              fi
            done

            # Check for connection errors in logs
            echo ""
            echo "üîç Checking for connection issues..."
            
            if docker logs trip-calculate-prod --tail 50 | grep -qi "connection.*refused\|unable to.*database\|authentication.*failed"; then
              echo "‚ö†Ô∏è Warning: Potential database connection issues"
              docker logs trip-calculate-prod --tail 50 | grep -i "database\|postgresql\|hikari"
            fi

            if docker logs trip-calculate-prod --tail 50 | grep -qi "redis.*connection.*refused\|unable to.*redis"; then
              echo "‚ö†Ô∏è Warning: Potential Redis connection issues"
              docker logs trip-calculate-prod --tail 50 | grep -i "redis"
            fi

            # ==================== DEPLOYMENT SUMMARY ====================
            echo ""
            echo "üéâ Deployment Summary:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Application: ‚úÖ Running on port 8080"
            echo "Database:    ‚úÖ Secured on private network (172.18.0.2)"
            echo "Redis:       ‚úÖ Secured on private network"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Security Checks:"
            echo "  DB Port:    $(docker port trip-calculate-db >/dev/null 2>&1 && echo '‚ùå EXPOSED!' || echo '‚úÖ NOT exposed')"
            echo "  Redis Port: $(docker port trip-calculate-redis >/dev/null 2>&1 && echo '‚ùå EXPOSED!' || echo '‚úÖ NOT exposed')"
            echo "  Health:     $(curl -sf http://localhost:8080/actuator/health >/dev/null && echo '‚úÖ Healthy' || echo '‚ùå Unhealthy')"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo ""
            echo "‚úÖ Production deployment complete!"
            echo ""
            echo "üì¶ Final container status:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep trip-calculate
          REMOTE

      - name: Cleanup SSH Key
        if: always()
        run: rm -f ~/.ssh/vps_deploy_key

      - name: Send Deployment Notification
        if: always()
        run: |
          echo "üéâ Production deployment completed for commit ${{ github.sha }}"